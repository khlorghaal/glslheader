//Khlor's header
//Copyright 2018 John Sherrill GNU GPLv3 https://www.gnu.org/licenses/gpl.txt

//Define-Switches
#define SHADERTOY
#define GLES

//Consts
#define PI  3.14159265359
#define TAU (PI*2.)
#define PHI 1.61803399
#define deg2rad 0.01745329251
#define SQRT2 (sqrt(2.))
#define BIG 1e8
#define ETA 1e-5
#define eqf(a,b) ( abs((a)-(b))<ETA )

//Aliases
#define fc gl_FragCoord.xy
#define res iResolution.xy
#define vec1 float
#define ivec1 int
#define uvec1 uint
#define len length
#define lerp mix
#define norm normalize
#define sat saturate
#define time float(iTime)
#define mouse ((iMouse.xy-res/2.)/(res*2.))
#define mouse_ang (mouse*vec2(PI, PI/2.))
#define tex texture

#ifdef SHADERTOY
#define mainImage(col,__) col= \
img(fc/res)
//vec4 img(vec2 uv){}
#endif


//vectorization macros
//I dont use these since I don't trust the optimizer to inline the lambda
//also multiline edit is easy
#define VECTORIZE_UNARY_FLOAT(f) \
vec2 f(vec2 a){ return vec2(f(a.x),f(a.y)); } \
vec3 f(vec3 a){ return vec3(f(a.x),f(a.y),f(a.z)); } \
vec4 f(vec4 a){ return vec4(f(a.x),f(a.y),f(a.z),f(a.w)); }
#define VECTORIZE_BINARY_FLOAT(f) \
vec2 f(vec2 a, vec2 b){ return vec2(f(a.x,b.x),f(a.y,b.y)); } \
vec3 f(vec3 a, vec3 b){ return vec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \
vec4 f(vec4 a, vec4 b){ return vec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }
#define VECTORIZE_UNARY_INT(f) \
ivec2 f(ivec2 a){ return ivec2(f(a.x),f(a.y)); } \
ivec3 f(ivec3 a){ return ivec3(f(a.x),f(a.y),f(a.z)); } \
ivec4 f(ivec4 a){ return ivec4(f(a.x),f(a.y),f(a.z),f(a.w)); }
#define VECTORIZE_BINARY_INT(f) \
ivec2 f(ivec2 a, ivec2 b){ return ivec2(f(a.x,b.x),f(a.y,b.y)); } \
ivec3 f(ivec3 a, ivec3 b){ return ivec3(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z)); } \
ivec4 f(ivec4 a, ivec4 b){ return ivec4(f(a.x,b.x),f(a.y,b.y),f(a.z,b.z),f(a.w,b.w)); }
/* example
float accumulate(float x){ return acc+= x; }
VECTORIZE_UNARY_FLOAT(accumulate);
An impure function is a weird but valid example
*/
#define VECTORIZE_SCALAR_ARG(f) \
vec2 f(vec2 x, vec1 y){ return _f(x,vec2(y));} \
vec3 f(vec3 x, vec1 y){ return _f(x,vec3(y));} \
vec4 f(vec4 x, vec1 y){ return _f(x,vec4(y));}


vec2 mods(vec2 x, vec1 y){ return mod(x,vec2(y));}
vec3 mods(vec3 x, vec1 y){ return mod(x,vec3(y));}
vec4 mods(vec4 x, vec1 y){ return mod(x,vec4(y));}
vec2 pows(vec2 x, vec1 y){ return pow(x,vec2(y));}
vec3 pows(vec3 x, vec1 y){ return pow(x,vec3(y));}
vec4 pows(vec4 x, vec1 y){ return pow(x,vec4(y));}
vec2 clamps(vec2 x, vec1 min, vec1 max){ return clamp(x, vec2(min),vec2(max));}
vec3 clamps(vec3 x, vec1 min, vec1 max){ return clamp(x, vec3(min),vec3(max));}
vec4 clamps(vec4 x, vec1 min, vec1 max){ return clamp(x, vec4(min),vec4(max));}
vec2 mins(vec2 v, vec1 s){ return min(v, vec2(s));}
vec3 mins(vec3 v, vec1 s){ return min(v, vec3(s));}
vec4 mins(vec4 v, vec1 s){ return min(v, vec4(s));}
vec2 maxs(vec2 v, vec1 s){ return max(v, vec2(s));}
vec3 maxs(vec3 v, vec1 s){ return max(v, vec3(s));}
vec4 maxs(vec4 v, vec1 s){ return max(v, vec4(s));}
vec2 mins(vec1 s, vec2 v){ return min(v, vec2(s));}
vec3 mins(vec1 s, vec3 v){ return min(v, vec3(s));}
vec4 mins(vec1 s, vec4 v){ return min(v, vec4(s));}
vec2 maxs(vec1 s, vec2 v){ return max(v, vec2(s));}
vec3 maxs(vec1 s, vec3 v){ return max(v, vec3(s));}
vec4 maxs(vec1 s, vec4 v){ return max(v, vec4(s));}

float maxv(vec2 a){ return                 max(a.x,a.y)  ;}
float maxv(vec3 a){ return         max(a.z,max(a.x,a.y)) ;}
float maxv(vec4 a){ return max(a.w,max(a.z,max(a.x,a.y)));}
float minv(vec2 a){ return                 min(a.x,a.y)  ;}
float minv(vec3 a){ return         min(a.z,min(a.x,a.y)) ;}
float minv(vec4 a){ return min(a.w,min(a.z,min(a.x,a.y)));}

//[ 0,1]->[-1,1]
vec1 nmaps(vec1 x){ return x*2.-1.; }
vec2 nmaps(vec2 x){ return x*2.-1.; }
vec3 nmaps(vec3 x){ return x*2.-1.; }
vec4 nmaps(vec4 x){ return x*2.-1.; }
//[-1,1]->[ 0,1]
vec1 nmapu(vec1 x){ return x*.5+.5; }
vec2 nmapu(vec2 x){ return x*.5+.5; }
vec3 nmapu(vec3 x){ return x*.5+.5; }
vec4 nmapu(vec4 x){ return x*.5+.5; }

float sum (vec2 v){ return dot(v,vec2(1));}
float sum (vec3 v){ return dot(v,vec3(1));}
float sum (vec4 v){ return dot(v,vec4(1));}
float prod(vec2 v){ return v.x*v.y;}
float prod(vec3 v){ return v.x*v.y*v.z;}
float prod(vec4 v){ return v.x*v.y*v.z*v.w;}

#define sqrtabs(x) sqrt(abs(x))
#define powabs(x,p) pow(abs(x),p)

vec1 saturate(vec1 x){ return clamp (x, 0.,1.);}
vec2 saturate(vec2 x){ return clamps(x, 0.,1.);}
vec3 saturate(vec3 x){ return clamps(x, 0.,1.);}
vec4 saturate(vec4 x){ return clamps(x, 0.,1.);}
#define lerpsat(a,b,x) lerp(a,b,saturate(x))

float pow2i(int x){ return float(1<<x); }

float angle(vec2 v){ return atan(v.y,v.x); }
vec1 angn(vec1 t){ return t-ceil(t/TAU-.5)*TAU; }
vec2 angn(vec2 t){ return t-ceil(t/TAU-.5)*TAU; }

bool real(vec1 x){ return !( isnan(x)||isinf(x) ); }
bool real(vec2 x){ return real(prod(x)); }
bool real(vec3 x){ return real(prod(x)); }
bool real(vec4 x){ return real(prod(x)); }

#define count(_n) for(int n=0; n!=_n; n++)

//im not sure if this is linear or srgb, or if that even matters much
#define LUMVEC vec3(0.2126, 0.7152, 0.0722)
float lum(vec3 c){ return dot(c,vec3(LUMVEC)); }

#define INT_MAX     0x7FFFFFFF
#define INT_HALFMAX 0x00010000
#define INT_MAXF     float(INT_MAX)
#define INT_HALFMAXF float(INT_HALFMAX)
vec1 unfix16(vec1 x){ return vec1(x)/INT_HALFMAXF; }
vec2 unfix16(vec2 x){ return vec2(x)/INT_HALFMAXF; }
vec3 unfix16(vec3 x){ return vec3(x)/INT_HALFMAXF; }
vec4 unfix16(vec4 x){ return vec4(x)/INT_HALFMAXF; }
ivec1 fixed16(vec1 x){ return ivec1(INT_HALFMAXF*x); }
ivec2 fixed16(vec2 x){ return ivec2(INT_HALFMAXF*x); }
ivec3 fixed16(vec3 x){ return ivec3(INT_HALFMAXF*x); }
ivec4 fixed16(vec4 x){ return ivec4(INT_HALFMAXF*x); }

ivec4 hash(ivec4 x){
	x= ((x>>16)^x)*0x45d9f3b;
	x= ((x>>16)^x)*0x45d9f3b;
	//x=  (x>>16)^x;
    return x;
}
vec1 hashf(vec1 x){ return abs(vec1(hash(ivec4(fixed16(x),0.,0.,0.)).x  ))/INT_MAXF; }
vec2 hashf(vec2 x){ return abs(vec2(hash(ivec4(fixed16(x),0.,0.   )).xy ))/INT_MAXF; }
vec3 hashf(vec3 x){ return abs(vec3(hash(ivec4(fixed16(x),0.      )).xyz))/INT_MAXF; }
vec4 hashf(vec4 x){ return abs(vec4(hash(ivec4(fixed16(x)         ))    ))/INT_MAXF; }

#define R2A vec2(.99231, .9933)
#define R2B vec2(.99111, .9945)
#define R3A vec3(.99312, .98313, .9846)
#define R3B vec3(.99111, .98414, .9935)
#define R4A vec4(.99412, .99343, .99565, .99473)
#define R4B vec4(.99612, .99836, .99387, .99376)
vec1 rand (vec1 x){ return hashf(x);   }
vec2 rand (vec2 x){ return hashf(x*hashf(dot(x,x+R2A))); }
vec3 rand (vec3 x){ return hashf(x*hashf(dot(x,x+R3A))); }
vec4 rand (vec4 x){ return hashf(x*hashf(dot(x,x+R4A))); }
vec1 rand1(vec2 x){ return hashf(dot(x*R2A-R2B,-x*R2B+R2A)/x.x);  }
//vec1 rand1(vec3 x){ return hashf(dot(x+R3A,x+R3B));  }
//vec1 rand1(vec4 x){ return hashf(dot(x+R4A,x+R4B));  }
vec2 rand2(vec1 x){ return hashf(x+R2A);   }
vec3 rand3(vec1 x){ return hashf(x+R3A);   }



//f0 is a param because its almost always calculated for something else
#define grad2(f,f0,x) \
	((vec2( \
    	f( x+vec2(ETA,0) ), \
		f( x+vec2(0,ETA) ) \
	)-f0)/ETA)
#define grad3(f,f0,x) \
	((vec3( \
    	f( x+vec3(ETA,0,0) ), \
		f( x+vec3(0,ETA,0) ), \
		f( x+vec3(0,0,ETA) ) \
	)-f0)/ETA)

#define gradnorm2(f,x)  \
	norm(vec3(grad2(f,x),1.))
#define gradnorm3(f,x)  \
	norm(grad3(f,x))

mat2 rot2d(float t){
    float c= cos(t);
    float s= sin(t);
    return mat2(
        c,-s,
        s, c
    );
    
}
mat3 rotx(float t){
    float c= cos(t);
    float s= sin(t);
    
    return mat3(
        1, 0, 0,
        0, c,-s,
        0, s, c
    );
}
mat3 roty(float t){
    float c= cos(t);
    float s= sin(t);
    
    return mat3(
         c,0,s,
         0,1,0,
    	-s,0,c
    );
}
mat3 rotz(float t){
    float c= cos(t);
    float s= sin(t);
    
    return mat3(
        c,-s,0,
        s, c,0,
    	0, 0,1
    );
}

//azimuth, inclination
vec3 azincl(vec2 a){
    a.x+= PI/2.;
    vec2 s= sin(a);//sin theta, sin phi
    vec2 c= cos(a);//cos theta, cos phi
    vec3 ret= vec3(c.x,s);
    ret.xy*= c.y;
    return ret;
}

struct ray{
	vec3 a;
    vec3 c;
};

#define FOV 110.
#define FOV_S tan(deg2rad*.5*FOV)
#define NEAR .1

ray look_persp(vec2 uv, vec2 a){
	ray o;
    o.a= norm( roty(a.x) * rotx(-a.y) * vec3(uv*FOV_S,1.));
    o.c= o.a*NEAR;
    return o;
}
ray look_orbit(vec2 uv, vec2 a, float d){
    ray o;
    mat3x3 mat= roty(a.x) * rotx(-a.y);
    o.a= norm( mat * vec3(uv*FOV_S,1.));
    o.c= mat[2]*-d + o.a*NEAR;
	return o;
}

#ifdef SHADERTOY
//rip from https://www.shadertoy.com/view/llySRh
#define KEY_LEFT   37
#define KEY_UP     38
#define KEY_RIGHT  39  
#define KEY_DOWN   40   
#define KEY_PGUP   33  
#define KEY_PGDOWN 34  
#define KEY_END    35  
#define KEY_HOME   36
#define KEY_SPACE  32
#define keyToggle(ascii)  ( texelFetch(iChannel3,ivec2(ascii,2),0).x > 0.)
#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)
#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)
#endif
